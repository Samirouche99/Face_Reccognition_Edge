    def detect_and_recognize_faces(self):
        self.running = True
        try:
            while self.running:
                ret, frame = self.cap.read()
                if not ret or frame is None:
                    time.sleep(0.1)
                    continue

                small_frame = cv2.resize(frame, (0, 0), fx=0.75, fy=0.75)
                rgb_small_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)
                face_locations = face_recognition.face_locations(rgb_small_frame, model='cnn')
                face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)

                current_time = time.time()
                padding = 20  # extra pixels around face crops

                for (top, right, bottom, left), face_encoding in zip(face_locations, face_encodings):
                    scale = 1 / 0.75
                    top, right, bottom, left = [int(coord * scale) for coord in (top, right, bottom, left)]

                    name, category = "Unknown", "Unknown"
                    matches = face_recognition.compare_faces(self.known_faces, face_encoding, tolerance=0.45)

                    height, width = frame.shape[:2]
                    top_pad = max(0, top - padding)
                    right_pad = min(width, right + padding)
                    bottom_pad = min(height, bottom + padding)
                    left_pad = max(0, left - padding)

                    if True in matches:
                        idx = matches.index(True)
                        category, name = self.known_names[idx]

                        last_log_time = self.last_known_log_times.get(name, 0)
                        if current_time - last_log_time > 30:
                            os.makedirs(LOG_SNAPSHOTS_DIR, exist_ok=True)
                            snapshot_path = os.path.join(LOG_SNAPSHOTS_DIR, f"{name}_{int(current_time)}.jpg")
                            face_crop = frame[top_pad:bottom_pad, left_pad:right_pad]
                            cv2.imwrite(snapshot_path, face_crop)

                            log_visit(name, category)
                            self.last_known_log_times[name] = current_time

                        color = self.category_colors.get(category, (255, 255, 255))
                    else:
                        color = (0, 0, 255)  # Red box for unknown
                        if current_time - self.last_unknown_save_time > self.cooldown_time:
                            unknown_dir = os.path.join(CAPTURED_FACES_DIR, "Unknown")
                            os.makedirs(unknown_dir, exist_ok=True)
                            unknown_path = os.path.join(unknown_dir, f"unknown_{int(current_time)}.jpg")
                            face_crop = frame[top_pad:bottom_pad, left_pad:right_pad]
                            cv2.imwrite(unknown_path, face_crop)
                            self.last_unknown_save_time = current_time

                    # Draw bounding box and label
                    cv2.rectangle(frame, (left, top), (right, bottom), color, 2)
                    label = f"{category}: {name}" if name != "Unknown" else "Unknown"
                    cv2.putText(frame, label, (left, top - 10),
                                cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

                with self.frame_lock:
                    self.latest_frame = frame.copy()

        except Exception as e:
            logging.error(f"Detection error: {e}")
        finally:
            if self.cap:
                self.cap.release()
                try:
                    cv2.destroyAllWindows()
                except:
                    pass